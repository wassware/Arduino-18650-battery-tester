The charge control uses a module based on the TP4056 chip. You can find chip datasheet on Google.
The module I used can be had from Ebay as something like 'TP4056 Lithium Charger Module with Battery Protection Micro USB 5V 1A' for around 80p or so each for 5 or more. The module circuit diagram and a photo are included here.
The 4056 chip handles the charge control and will indicate with leds when done. Peak charge current is configured to 1A, starting to drop when the voltage gets to 4.16V. Charge complete is when current drops to 10% (0.1A). It is a shunt regulator so at peak it needs to dissipate 2W and does get hot. It has internal thermal regulation so limits current to what to can cope with. 
The module also contains the DW01A protection chip and a series pair of MOSFETS on the battery negative side to limit minimum and maximum cell voltage and current. This is a sound precaution for working with unprotected lithium cells. 
The volt drop over the MOSFETS is used to measure the current for the protection chip. Being on the negative line this does influence the battery voltage read  by the Arduino. I measured 55mv at around 1A discharge so this can be compensated for. Its only an issue in discharge. Part of calibration is to measure the voltage as the Arduino analog sees it against te cell voltage at the reference voltage of 3.7v to get an adjustment factor.
To switch charge on and off needs a hack as the 4056 Enable pin is wired high. So pin 8 connection to the board needs cutting. This is the one next to the R2 characters on the board picture. Very fine snips may work. I found that gently sawing with a fine craft knife blade worked well for me. Slip a piece of paper through the break then solder a fine wire on to the chip leg to provide enable (active high) control. After testing I blobbed Araldite on the joint.
Now in the first version I discovered a trick. Soldering pin 8 (enable) and pin 6 (charge complete LED driver) together turned the control into a flip flop. An Arduino IO could be set to output, pulled up or down and set back to input. This could change the enable state to control charging. On charge complete it would switch to enable off by itself. So a single pin to control and read charging state. With one other IO to control the discharge MOSFET and with the 6 analog inputs the Arduino could manage 6 cells and use up all the available interfaces.
During initial testing I blew a few chips with careless soldering and the replacement charger modules did not behave the same way - must have been a different clone chip. With the alternative of using another IO to read the charge state and ending up with 4 cell design I opted to detect charge complete by monitoring the battery voltage. So only the enable pin is interfaced to the Arduino. 
Discharge is using the trusty IRF520N MOSFET that can be driven directly from an Arduino output. The load resistors are two 8R or 8R2 5W resistors in parallel to give a starting discharge current of around 1A.
The Arduino reads the battery voltage direct. To give stability the VRef is provided at 4.3v with a TL431A shunt voltage reference chip. This needs three resistors and a capacitor to configure.
Power for charging is delivered by a 5V 10A switched supply. The Arduino board is powered separately. Maybe it can be powered from the same supply.
There can be a lot of heat generated in charge and more in discharge. I had a 4 inch ex PSU fan that spins enough at 5v and mounted it helicopter style over the top. The layout as you see had plenty of air flow space.
The design does not have thermal monitoring. As the cells are well exposed and not burried in a pack overheating risk is slight. A bad cell that never hits charge complete sometimes gets warm. The code has some detection logic to spot a malcharging cell.
The 18650 cell holder wires and connections had significant volt drop so soldered new wires to the spring and the positive cell button.
Interface is the serial monitor to laptop. To see what is going on remotely from a phone with a serial Bluetooth monitor I used an ESP32 as a Bluetooth slave interface. An HC06 or similar would do the same job.

